# -*- coding: utf-8 -*-

# Copyright (C) 2006-2010 ianaré sévi <ianare@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

from __future__ import print_function
import utils
import os
import time
import codecs
import platform
import sys

import shutil1 # some earlier python versions have a bug in shutil
import classes

class Core():
    """
    Renaming Engine.

    Takes names generated by the preview and applies changes to disc.
    Able to undo renaming operations.
    """
    def __init__(self, MainWindow):
        global main
        main = MainWindow
        self.setup()

    def _set_display(self, i):
        """Refreshes display and main window during renaming operation."""
        main.bottomWindow.display.EnsureVisible(i)
        main.bottomWindow.display.Refresh()
        main.Update()

    def _show_rename_error(self, i, err, original, renamed):
        """Show renaming errors."""
        err = err.decode(sys.getfilesystemencoding())
        # set item as bad
        main.toRename[i][1][1] = None
        self._set_display(i)
        # show error message
        main.set_status_msg(_("Renaming Failed : %s")%err, u'failed')
        utils.make_err_msg(_(u"Error renaming:\n%s \n\nto:\n%s \n\nReason: %s")\
                         %(original[0],renamed[0],err),
                         _(u"Renaming Failed !!"))


    def _rename_item(self, i, original, renamed, refresh_int):
        """
        Renaming operation, with recursive error handling.

        Returns False on success.
        """
        try:
            shutil1.move(original[0], renamed[0], True)
        except IOError as (errNumb, err):
            if main.debug:
                print("IOError : %s, %s"%(errNumb, err))
            # may need to create dirs first
            if errNumb == 2 and not os.path.exists(os.path.dirname(renamed[0])):
                try:
                    os.makedirs(os.path.dirname(renamed[0]))
                except OSError as (n, err):
                    self._show_rename_error(i, err, original, renamed)
                    return 'makedirs'
                else:
                    return self._rename_item(i, original, renamed, refresh_int)
            else:
                self._show_rename_error(i, err, original, renamed)
                return True
        except OSError as (errNumb, err):
            if main.debug:
                print("OSError : %s, %s"%(errNumb, err))
            # don't stop for a read-only error if the renamed item exists
            if not (errNumb == 30 and os.path.exists(renamed[0])):
                self._show_rename_error(i, err, original, renamed)
                return True

        # set item as renamed
        main.toRename[i][1][1] = True

        # refresh based on user settings
        if i % refresh_int == 0:
            self._set_display(i)

        # renaming is successful
        return False


    def _compare(self, renamed, original):
        """Dupe checking, windows is case insensitive."""
        renamed = renamed[0]
        original = original[0]
        if platform.system() == 'Windows':
            renamed = renamed.lower()
            original = original.lower()
        if renamed != original:
            return True
        else:
            return False


    def _rename_item_list(self, event):
        """After pre-renaming checks are completed, rename the list of items."""
        # calculate refresh settings
        count = len(main.toRename)
        count = count / 25 + 1
        if count > int(self.prefs.get('renRefreshMin')):
            count = int(self.prefs.get('renRefreshMin'))

        # define here for faster processing
        def exists(item):
            return os.path.exists(item)
        def join(a,b,c):
            return unicode(os.path.join(a,b,c))

        warn = False
        if event != u'undo':
            path = main.picker.params.root

        # renaming operation:
        i = 0
        for original, renamed in main.toRename:
            if warn != 'duplicate_name' and self._compare(renamed, original) and\
              exists(renamed[0]):
                # set item as bad
                main.toRename[i][1][1] = None
                self._set_display(i)
                main.set_status_msg(_(u"Duplicate name"), u'warn')
                msg = _(u"This name already exists:\n%s")%renamed[0]\
                    +_(u"\n\nI can make a sub-folder called 't_e_m_p' and do the renaming operation there.\nYou can then move everything back.\n\nGo ahead and do this?")
                title = _(u"Duplicate name")
                if utils.make_yesno_dlg(msg, title):
                    warn = 'duplicate_name'
                else:
                    error = True
                    break

            # set correct path if in dupe error mode
            if warn == 'duplicate_name':
                if not path.endswith(os.sep):
                    path = path+os.sep
                renamed[0] = renamed[0].replace(path,u'')
                renamed[0] = join(path, u't_e_m_p', renamed[0])

            # write name to undo
            self.originalFile.write(original[0] + u'\n')
            self.renamedFile.write(renamed[0] + u'\n')

            # the actual renaimg op
            error = self._rename_item(i, original, renamed, count)

            if error:
                break

            i += 1

            if main.debug:
                try:
                    print(original[0])
                    print(renamed[0])
                    print()
                except:
                    print('could not display name on this terminal')
                    print()

        return error, i


    def _print_list(self, list):
        """Print out a list (for testing/debug)."""
        for item in list:
            print(item)

    def setup(self):
        """Should be called before running to intialise."""
        self.prefs = main.prefs

    def rename(self, event):
        """
        Write undo files first (safety first !), then attemp to perform
        the renaming operation.
        """
        
        itemsRenamed = 0
        error = False
        main.currentItem = None
        main.bottomWindow.display.mode = 'rename'
        utils.set_busy(True)
        main.picker.view.path.SetEditable(False)

        ##### BEGIN HEAVY TESTING ##############################################

        # adjust and sort items when recursively renaming folders
        if main.recursiveFolderOn and event != u'undo':
            main.set_status_msg(_(u"Adjusting %s recursive paths, please wait ...")%len(main.toRename),u'wait')

            progressDialog = classes.ProgressDialog(main, self.prefs, main.items,
                             _(u"Adjusting %%% recursive paths, please wait ..."))

            if main.show_times:
                t = time.time()

            # define these here for faster processing
            def os_split(item):
                return os.path.split(item)
            def add_sep(path):
                return os.sep + path + os.sep
            # order by path depth
            def recursive_folder_sort(x, y):
                x = x[1][0].count(os.sep)
                y = y[1][0].count(os.sep)
                return cmp(x, y)

            main.toRename.sort(recursive_folder_sort)
            sortedRename = main.toRename

            # make a list of all folders that will be processed
            foldersToAdjust = []
            for item in sortedRename:
                # only grab folders
                if not item[0][1]:
                    #oF = os_split(item[0][0])[0] # original folder name
                    #nF = os_split(item[1][0])[0] # new folder name
                    oF = item[0][0]
                    nF = item[1][0]
                    if oF is not nF:
                        print(oF, nF)
                        #print item[1][0].count(os.sep)
                        foldersToAdjust.append((oF, nF))
            sys.exit()

            # replace all occurences of folders in path
            for i in range(len(main.toRename)):

                print(foldersToAdjust)
                for f in foldersToAdjust:
                    oF = add_sep(f[0]) # original folder name

                    # continue from this point for faster processing
                    if oF not in main.toRename[i][0][0]:
                        continue

                    nF = add_sep(f[1]) # new folder name

                    print(oF, nF)
                    #print testing(i,oF,nF)

                    print(main.toRename[i][0][0])
                    print(main.toRename[i][0][0].replace(oF,nF,1))
                    print()

                    main.toRename[i][0][0] = main.toRename[i][0][0].replace(oF,nF,1)
                    main.toRename[i][1][0] = main.toRename[i][1][0].replace(oF,nF,1)

                #if not progressDialog.update(i):
                #    error = 'cancelled'
                #    break

            # make sure renaming will be in correct order !
            main.toRename.sort(recursive_folder_sort)

            progressDialog.destroy()

            if main.show_times:
                print("%s items recursive adjust : %s"%(len(main.toRename), (time.time() - t)))

            #self._print_list(foldersToAdjust)
            #self._print_list(main.toRename)
            sys.exit()
            
        ##### END HEAVY TESTING ################################################

        if not error:
            main.set_status_msg(_(u"Renaming in progress, please wait ..."),u'wait')

            # open undo files for writing
            try:
                self.originalFile = codecs.open(utils.get_user_path(u'undo/original.bak'),'w',"utf-8")
                self.renamedFile = codecs.open(utils.get_user_path(u'undo/renamed.bak'),'w',"utf-8")
            except IOError as (n, strerror):
                msg = strerror + _(u"\nMake sure 'undo' directory exists and is read/write\n\nYou will not be able to undo!!\nDo you want to continue??")
                title = _(u"Problem with undo!")
                if not utils.make_yesno_dlg(msg, title):
                    error = 'cancelled'
                dlg.Destroy()

        # enough checking, DO IT !!
        if not error:
            if main.show_times:
                t = time.time()
            # rename the item list
            error, itemsRenamed = self._rename_item_list(event)

        # end of operations
        if not error:
            main.set_status_msg(_(u"Renaming for %s items completed")
                              %itemsRenamed, u"complete")
            if self.prefs.get('reloadAfterRename') and event != u'undo':
                main.picker.refresh(event)
            else:
                main.picker.clear_all()
            if self.prefs.get(u'alwaysMakeLog'):
                main.save_items_as_text(False)
        elif error == 'cancelled':
            main.set_status_msg(_(u"Renaming cancelled"), u'failed')

        utils.set_busy(False)
        self._set_display(len(main.toRename)-1)

        if main.show_times:
            print("%s items renamed : %s"%(itemsRenamed, (time.time() - t)))

        # auto
        if main.autoModeLevel > 2 and not error:
            print(_(u"Renaming for %s items completed")%itemsRenamed)
            sys.exit()

        main.picker.refresh_dir_tree()

        main.bottomWindow.go.Enable(False)
        main.menuFile.GoMenu.Enable(False)
        if event != 'undo':
            main.bottomWindow.set_undo_redo_type('undo')
        main.picker.view.path.SetEditable(True)


    def undo_last_rename(self, event):
        """
        Grabs names from .bak files and reverts them to their originals.
        
        Keep this separate from csv file functions for safety and stability.
        """
        
        original = []
        renamed = []
        utils.set_busy(True)
        try:
            originalFile = codecs.open(utils.get_user_path(u'undo/original.bak'),'r',
                           'utf-8')
            renamedFile = codecs.open(utils.get_user_path(u'undo/renamed.bak'),'r',
                          'utf-8')
            for line in originalFile:
                original.append([line.strip(),False])
            for line in renamedFile:
                renamed.append([line.strip(),1])

        except IOError as error:
            utils.make_err_msg(_(u"%s\n\nUndo Failed !!")%error, _(u"Error"))
            pass
        else:
            def get_name(x): return x[0]
            commonPrefix = os.path.commonprefix(map(get_name,original)).rstrip(os.sep)
            if os.path.exists(commonPrefix):
                main.picker.view.path.SetValue(commonPrefix)
                main.picker.view.dirPicker.SetPath(commonPrefix)

            if not len(original) == 0:
                main.toRename = zip(renamed,original)#reverse order from original rename!
                main.currentItem = None
                main.display_results()
                main.rename_items(u'undo')
                main.menuFile.SaveLog.Enable(False)
            else:
                main.set_status_msg(_(u"Nothing to undo"), u'eyes')

        main.bottomWindow.set_undo_redo_type('check')
        utils.set_busy(False)
